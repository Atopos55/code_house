<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>云锦风格3D模型贴图生成器</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static',filename='css/ini.css')}}">
</head>
<body>
        <!-- 返回主页的按钮 -->
    <div class="back-home">
        <a href="/" class="back-button">
            <svg viewBox="0 0 24 24" width="24" height="24">
                <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
            </svg>
            返回主页
        </a>
    </div>
    <h1>云锦风格3D模型贴图生成器</h1>
    
    <div class="control-panel">
        <div class="model-selector">
            <div class="model-option" data-model="马克杯">马克杯</div>
            <div class="model-option" data-model="旗袍">旗袍</div>
            <div class="model-option" data-model="汉服">汉服</div>
            <div class="model-option" data-model="画框冰箱贴">画框冰箱贴</div>
            <div class="model-option" data-model="扇面冰箱贴">扇面冰箱贴</div>

        </div>
        
        <div class="input-group">
            <label for="color-input">颜色描述</label>
            <input type="text" id="color-input" placeholder="例如：深红色和金色">
            <div class="example-text">建议格式：主色+辅助色，如"宝蓝色配银白色"</div>
        </div>
        
        <div class="input-group">
            <label for="pattern-input">图案描述</label>
            <input type="text" id="pattern-input" placeholder="例如：祥云和龙凤纹">
            <div class="example-text">传统纹样：牡丹、缠枝莲、八宝纹等</div>
        </div>
        
        <div class="input-group">
            <label for="sort-input">云锦种类描述</label>
            <input type="text" id="sort-input" placeholder="例如：妆花配扁金线">
            <div class="example-text">建议格式：云锦种类+线的种类，如"妆花配扁金线"</div>
        </div>

        <button id="generate-btn">生成云锦贴图</button>
        <button id="watch-btn" onclick="window.location.href='{{ url_for('inde')}}'">查看3d模型</button>
        <button id="price-btn" onclick="window.location.href='{{ url_for('price')}}'">查询云锦定价</button>
    </div>
    
    <div class="model-viewer">
        <h2 id="model-title">马克杯（未贴图）</h2>
        <div class="model-container" id="model-container">
            <canvas id="model-canvas"></canvas>
        </div>
        <div class="progress-container" id="progress-container">
            <progress id="generation-progress" value="0" max="100"></progress>
            <div class="status-message" id="status-message">准备生成...</div>
        </div>
        <button id="download-btn" style="display:none;" target="_blank">下载生成的模型</button>
    </div>

    <script>
        if (typeof THREEFBXLoader === 'undefined') {
            THREEFBXLoader = {
                fflate: window.fflate
            };
        }
        
        // 当前选中的模型
        let selectedModel = '马克杯';
        let currentScene = null;
        let currentRenderer = null;
        let currentModel = null;
        let animationId = null;

        // 初始化模型选择
        document.querySelectorAll('.model-option').forEach(option => {
            option.addEventListener('click', function() {
                // 更新UI选择状态
                document.querySelectorAll('.model-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                this.classList.add('selected');
                
                // 更新当前选择的模型
                selectedModel = this.dataset.model;
                document.getElementById('model-title').textContent = `${selectedModel}（未贴图）`;
                
                // 加载并显示白膜模型
                loadFBXModel(`./static/models/${selectedModel}.fbx`);
            });
        });

        // 默认选择第一个模型
        document.querySelector('.model-option').click();

        // 加载并显示FBX格式的3D模型
        function loadFBXModel(modelPath) {
            const container = document.getElementById('model-container');
            container.innerHTML = '<canvas id="model-canvas"></canvas>';
            
            // 清除之前的动画循环
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // 初始化Three.js场景
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('model-canvas'), 
                antialias: true,
                preserveDrawingBuffer: true // 允许截图
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            
<!--            // 添加光源-->
<!--            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);-->
<!--            scene.add(ambientLight);-->
<!--            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);-->
<!--            directionalLight.position.set(1, 1, 1);-->
<!--            scene.add(directionalLight);-->
            // 添加更强的光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // 更强的环境光
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight1.position.set(3, 5, 2);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, 0.5, -1);
            scene.add(directionalLight2);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
            scene.add(hemisphereLight);

            // 加载FBX模型
            const loader = new THREE.FBXLoader();
            loader.load(
                modelPath,
                (object) => {
                    // 清除旧场景
                    if (currentScene) {
                        while(currentScene.children.length > 0) {
                            currentScene.remove(currentScene.children[0]);
                        }
                    }
                    
                    scene.add(object);
                    currentScene = scene;
                    currentModel = object;
                    
                    // 调整相机位置
                    const bbox = new THREE.Box3().setFromObject(object);
                    const center = bbox.getCenter(new THREE.Vector3());
                    const size = bbox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
                    
                    camera.position.z = cameraZ * 0.8;
                    camera.lookAt(center);
                    
                    // 动画循环
                    function animate() {
                        animationId = requestAnimationFrame(animate);
                        object.rotation.y += 0.005;
                        renderer.render(scene, camera);
                    }
                    animate();
                },
                undefined,
                (error) => {
                    console.error('模型加载错误:', error);
                    container.innerHTML = `<p style="color:red;">模型加载失败: ${error.message}</p>`;
                }
            );
            
            // 窗口大小调整
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        document.getElementById('generate-btn').addEventListener('click', async function() {
            const color = document.getElementById('color-input').value.trim();
            const pattern = document.getElementById('pattern-input').value.trim();
            const sort = document.getElementById('sort-input').value.trim();
            
            if (!color) {
                alert('请输入颜色描述');
                return;
            }
            else if(!pattern){
                alert('请输入图案描述');
                return; 
            }
            else if(!sort){
                alert('请输入云锦种类描述');
                return; 
            }
            this.disabled = true;
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('generation-progress');
            const statusMessage = document.getElementById('status-message');
            progressContainer.style.display = 'block';
            document.getElementById('model-title').textContent = `${selectedModel}（生成中...）`;
            
            try {
                // 1. 准备模型文件
                statusMessage.textContent = "准备模型文件中...";
                progressBar.value = 10;
                
                // 使用GLB模型文件
                const modelFile = await fetchModelFile(`./static/models/${selectedModel}.glb`);
                
                // 2. 调用Meshy API
                statusMessage.textContent = "提交生成请求...";
                progressBar.value = 20;
                
                const formData = new FormData();
                formData.append('model_file', modelFile, `./static/models/${selectedModel}.glb`);
                formData.append('object_prompt', selectedModel);
                formData.append('style_prompt', `中国传统南京云锦样式，图案为${pattern}，色调为${color}，云锦种类为${sort},丝绸质感`);
                formData.append('art_style', 'realistic-hand-drawn');
                formData.append('resolution', '4096');
                formData.append('enable_original_uv', 'true');
                formData.append('enable_pbr', 'true');
                formData.append('output_format', 'fbx');
                formData.append('negative_prompt', '低质量, 现代风格, 简约,丑陋,纯色');
                
                const response = await fetch('https://api.meshy.ai/v1/text-to-texture', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer msy_cb69ajz06R9BdrJxOnTaOY8hAr9QuzIrPMW2'
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `API请求失败: ${response.status}`);
                }
                
                const data = await response.json();
                console.log("API响应:", data);
                const taskId = data.id || data.result;
                if (!taskId) throw new Error('无法获取任务ID');
                progressBar.value = 30;
                
                // 3. 轮询任务状态
                let finished = false;
                while (!finished && progressBar.value < 100) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    const statusResponse = await fetch(`https://api.meshy.ai/v1/text-to-texture/${taskId}`, {
                        headers: { 
                            'Authorization': 'Bearer msy_cb69ajz06R9BdrJxOnTaOY8hAr9QuzIrPMW2',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!statusResponse.ok) {
                        const errorData = await statusResponse.json().catch(() => ({}));
                        throw new Error(errorData.message || `状态查询失败: ${statusResponse.status}`);
                    }
                    
                    const statusData = await statusResponse.json();
                    console.log("任务状态:", statusData);
                    progressBar.value = statusData.progress || progressBar.value + 10;
                    statusMessage.textContent = getStatusMessage(statusData.status);
                    
                    if (statusData.status === 'SUCCEEDED') {
                        finished = true;
                        progressBar.value = 100;
                        
                        // 获取模型URL
                        const modelUrl =statusData.model_urls.fbx;
                        
                        if (!modelUrl) {
                            throw new Error('未找到模型下载链接');
                        }
                        
                        // 显示下载按钮并绑定事件
                        const downloadBtn = document.getElementById('download-btn');
                        downloadBtn.style.display = 'inline-block';
                        downloadBtn.onclick = () => {
                            window.open(modelUrl, '_blank');
                        };
                        
                        
                        
                    } else if (statusData.status === 'FAILED') {
                        console.error(statusData.error?.message || statusData.task_error?.message || '生成失败');
                        // 暂停10秒
                        await new Promise(resolve => setTimeout(resolve, 10000));
                        continue;
                    }
                }
            } catch (error) {
                console.error('生成失败:', error);
                statusMessage.textContent = `错误: ${error.message}`;
                progressBar.value = 0;
            } finally {
                this.disabled = false;
            }
        });
// 获取模型文件
async function fetchModelFile(modelPath) {
            try {
                const response = await fetch(modelPath);
                if (!response.ok) {
                    throw new Error(`无法加载模型文件: ${response.status}`);
                }
                return await response.blob();
            } catch (error) {
                console.error('模型加载失败:', error);
                throw new Error(`无法加载${modelPath}模型文件`);
            }
        }

        function getStatusMessage(status) {
            const messages = {
                'PENDING': '排队等待处理...',
                'IN_PROGRESS': '正在生成云锦贴图...',
                'SUCCEEDED': '生成完成！',
                'FAILED': '生成失败'
            };
            return messages[status] || `状态: ${status}`;
        }
        // ... 其他辅助函数保持不变 ...
    </script>
</body>
</html>